{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Frontless is an isomorphic web framework built for next generation web applications. It lets you build server-side rendered web applications using RiotJS and FeathersJS . At the core, Frontless is just an express.js server that provides routing, data access, web sockets and user sessions. It is just an express.js aplication you can customize at will It is built with \u2764\ufe0f RiotJS. It provides natural HTTP routing [page.riot -> GET /page] It uses FeathersJS on client and server It allows to update components' state directly from server response The Stack Before you start, it is highly recommended to have essential understanding of following technologies: FeathersJS | RiotJS | Turbolinks | ExpressJS Stack summary SERVER CLIENT Routing [express.js] Navigation [turbolinks] View Model [feathers] Data Representation [riot.js] Layout Rendering [riot/ssr] User input [riot.js] Sessions [express.js] JWT, Cookies Realtime [feathers, socket.io] FeathersJS Client DB Interface [@feathers/client] Rest/IO [@feathers/client] Getting Started Clone this repo or use NPX npx create-frontless <app-name> Setup a MongoDB Server (optional). Frontless reads MONGODB_URI environment variable. # config.env MONGODB_URI=mongodb://localhost:27017/frontless Install dependencies and start dev. server npm run install npm start \u041epen http://localhost:6767 in your browser. Navigate to the playground for examples Directory Structure \u251c\u2500\u2500 assets # static assets | \u2514\u2500\u2500 ... \u251c\u2500\u2500 components # components | \u2514\u2500\u2500 ... \u251c\u2500\u2500 pages # site pages | \u2514\u2500\u2500 ... \u251c\u2500\u2500 services # feathers services | \u2514\u2500\u2500 ... \u251c\u2500\u2500 tests # tests | \u2514\u2500\u2500 ... \u251c\u2500\u2500 client.js # feathers.js client \u251c\u2500\u2500 plugins.js # riot.js plugins \u2514\u2500\u2500 index.js # entry point of express application","title":"Introduction"},{"location":"#introduction","text":"Frontless is an isomorphic web framework built for next generation web applications. It lets you build server-side rendered web applications using RiotJS and FeathersJS . At the core, Frontless is just an express.js server that provides routing, data access, web sockets and user sessions. It is just an express.js aplication you can customize at will It is built with \u2764\ufe0f RiotJS. It provides natural HTTP routing [page.riot -> GET /page] It uses FeathersJS on client and server It allows to update components' state directly from server response","title":"Introduction"},{"location":"#the-stack","text":"Before you start, it is highly recommended to have essential understanding of following technologies: FeathersJS | RiotJS | Turbolinks | ExpressJS Stack summary SERVER CLIENT Routing [express.js] Navigation [turbolinks] View Model [feathers] Data Representation [riot.js] Layout Rendering [riot/ssr] User input [riot.js] Sessions [express.js] JWT, Cookies Realtime [feathers, socket.io] FeathersJS Client DB Interface [@feathers/client] Rest/IO [@feathers/client]","title":"The Stack"},{"location":"#getting-started","text":"Clone this repo or use NPX npx create-frontless <app-name> Setup a MongoDB Server (optional). Frontless reads MONGODB_URI environment variable. # config.env MONGODB_URI=mongodb://localhost:27017/frontless Install dependencies and start dev. server npm run install npm start \u041epen http://localhost:6767 in your browser. Navigate to the playground for examples","title":"Getting Started"},{"location":"#directory-structure","text":"\u251c\u2500\u2500 assets # static assets | \u2514\u2500\u2500 ... \u251c\u2500\u2500 components # components | \u2514\u2500\u2500 ... \u251c\u2500\u2500 pages # site pages | \u2514\u2500\u2500 ... \u251c\u2500\u2500 services # feathers services | \u2514\u2500\u2500 ... \u251c\u2500\u2500 tests # tests | \u2514\u2500\u2500 ... \u251c\u2500\u2500 client.js # feathers.js client \u251c\u2500\u2500 plugins.js # riot.js plugins \u2514\u2500\u2500 index.js # entry point of express application","title":"Directory Structure"},{"location":"api/","text":"API Out of the box Frontless provides user sessions, a MongoDB connection and user authentication strategy with FeathersJS. FeathersJS Client To achieve universal behaviour on server and client Frontless utilizes Feathers Client . Unauthorized Client: import 'client' from 'client' const Model = client.service('/myservice') Model.create({message: 'hello!'}).then((res)=>{ alert('Message created!') }) Authotized Client: The client property in a RiotJS component context sends authorized requests on client and server. export default { createItem(data){ const Model = this.client.service('items') Model.create(data) } } Services A service is a set of CRUD methods. In Frontless services can be accessed whether with REST client or Socket.IO Feathers readme on services Example: const {MONGO_DATABASE} = process.env module.exports = (app, mongo) => { const Model = mongo.db(MONGO_DATABASE).collection('mydata') app.use('myservice', { async find() { return [] }, async get() { return {} }, async create() { return {} }, async update() { return [] }, async remove() { return [] }, }) app.service('myservice').hooks({ before: { create: [ ], remove: [ ] } }); } MongoDB At initialization Frontless tries to connect to MongoDB server using MONGODB_URI variable. Frontless does not provide an ODM out of the box, but connecting one is as easy as in any node.js application. Instead we suggesst to consider following Feathers features: Fetthers Querying Feathers JS MongoDB Plugin Request context On the server side every RiotJS component has access to express.js context. req and res are passed to the fetch method with other props. Also this.req and this.res are available in component context. Example: export default { async fetch({req, res}){ //use req, res }, aMethod(){ const {req, res} = this; } } Sessions Express.js session middleware provides sessions. Accessing within services: app.use('increment', { // enter chat with nickname async get(number, params) { params.request.session['number'] = parseInt(number) + 1; params.request.session.save(); return {}; } }) CORS Allowed origins are stored in the ALOWED_HOSTS environment variable. Beware, by deafult all hosts are allowed which is not recommended on an production deploy. Auth Frontless utilizes @feathersjs/authentication-local module to provide authentication strategy for your applications. The authentication token is stored in cookies so it is mandatory to use CORS and HTTPS if your app has restricted areas. Example: this.client.authenticate({ strategy: 'local', username, password, }). then((res) => { return this.client.passport.verifyJWT(res.accessToken) }). then((res) => { this.redirect('/profile') }). catch((err) => { console.log(err) }) Security Beware that all components including pages are compiled for browser as well. So it is NOT recommended to use sensitive variables or use any sentive data as open text inside your riot components When working with Riot Components, is is HIGHLY recommended to use functional approach. Every component should be returned from a function like export default ()=> ({...component}). This is needed to avoid module caching Under no circumstances, It is NOT recommended to turn off the CORS middlewares or use * on production deploys.","title":"API"},{"location":"api/#api","text":"Out of the box Frontless provides user sessions, a MongoDB connection and user authentication strategy with FeathersJS.","title":"API"},{"location":"api/#feathersjs-client","text":"To achieve universal behaviour on server and client Frontless utilizes Feathers Client . Unauthorized Client: import 'client' from 'client' const Model = client.service('/myservice') Model.create({message: 'hello!'}).then((res)=>{ alert('Message created!') }) Authotized Client: The client property in a RiotJS component context sends authorized requests on client and server. export default { createItem(data){ const Model = this.client.service('items') Model.create(data) } }","title":"FeathersJS Client"},{"location":"api/#services","text":"A service is a set of CRUD methods. In Frontless services can be accessed whether with REST client or Socket.IO Feathers readme on services Example: const {MONGO_DATABASE} = process.env module.exports = (app, mongo) => { const Model = mongo.db(MONGO_DATABASE).collection('mydata') app.use('myservice', { async find() { return [] }, async get() { return {} }, async create() { return {} }, async update() { return [] }, async remove() { return [] }, }) app.service('myservice').hooks({ before: { create: [ ], remove: [ ] } }); }","title":"Services"},{"location":"api/#mongodb","text":"At initialization Frontless tries to connect to MongoDB server using MONGODB_URI variable. Frontless does not provide an ODM out of the box, but connecting one is as easy as in any node.js application. Instead we suggesst to consider following Feathers features: Fetthers Querying Feathers JS MongoDB Plugin","title":"MongoDB"},{"location":"api/#request-context","text":"On the server side every RiotJS component has access to express.js context. req and res are passed to the fetch method with other props. Also this.req and this.res are available in component context. Example: export default { async fetch({req, res}){ //use req, res }, aMethod(){ const {req, res} = this; } }","title":"Request context"},{"location":"api/#sessions","text":"Express.js session middleware provides sessions. Accessing within services: app.use('increment', { // enter chat with nickname async get(number, params) { params.request.session['number'] = parseInt(number) + 1; params.request.session.save(); return {}; } })","title":"Sessions"},{"location":"api/#cors","text":"Allowed origins are stored in the ALOWED_HOSTS environment variable. Beware, by deafult all hosts are allowed which is not recommended on an production deploy.","title":"CORS"},{"location":"api/#auth","text":"Frontless utilizes @feathersjs/authentication-local module to provide authentication strategy for your applications. The authentication token is stored in cookies so it is mandatory to use CORS and HTTPS if your app has restricted areas. Example: this.client.authenticate({ strategy: 'local', username, password, }). then((res) => { return this.client.passport.verifyJWT(res.accessToken) }). then((res) => { this.redirect('/profile') }). catch((err) => { console.log(err) })","title":"Auth"},{"location":"api/#security","text":"Beware that all components including pages are compiled for browser as well. So it is NOT recommended to use sensitive variables or use any sentive data as open text inside your riot components When working with Riot Components, is is HIGHLY recommended to use functional approach. Every component should be returned from a function like export default ()=> ({...component}). This is needed to avoid module caching Under no circumstances, It is NOT recommended to turn off the CORS middlewares or use * on production deploys.","title":"Security"},{"location":"config/","text":"Configuration Variables Server configuration is kept in environment variables. Must change variables: HTTP_SESSION_SECRET HTTP_SESSION_SECURE REST_AUTH_SECRET ALOWED_HOSTS ORIGIN Running application Before running on prod environment build minified version and set NODE_PATH to include application directory. Normally it would result in following steps: Run gulp build Run NODE_PATH=\\\".:./node_modules\\\" node index.js ./config.env","title":"Configuration"},{"location":"config/#configuration","text":"","title":"Configuration"},{"location":"config/#variables","text":"Server configuration is kept in environment variables. Must change variables: HTTP_SESSION_SECRET HTTP_SESSION_SECURE REST_AUTH_SECRET ALOWED_HOSTS ORIGIN","title":"Variables"},{"location":"config/#running-application","text":"Before running on prod environment build minified version and set NODE_PATH to include application directory. Normally it would result in following steps: Run gulp build Run NODE_PATH=\\\".:./node_modules\\\" node index.js ./config.env","title":"Running application"},{"location":"plugins/","text":"Plugins RiotJS Plugins RiotJS Plugins are configured in the ./plugins.js . Before installing plugins you should consider how they work on the server environment. By default there are serveral plugins which provide functionality for frontless. It is not recommended to delete initial code from ./plugins.js Frontless Plugins Frontless provides a simple plugin api. A frontless Plugin installation A plugin must be placed inside components directory. Then you need to call install on the plugin entry point const {install, withPlugins} = require('components/utils/plugins') const pluginExample = require('components/nesterow/frontless-plugin') install(pluginExample) Plugin initialization Depending on the purpose, a plugin can have three initialization steps: 1. setup - calls when Frontless initialized express 2. setupSSR - calls before SSR middlewares are initialized 3. connected - calls after database in connected Example plugin entry: const Middleware = require('components/utils/middleware') module.exports = ({ name: 'Example plugin', setup(app, dirname) { app.use((req, res, next) => { console.log('Example plugin middleware') next(); }) }, setupSSR(app, dirname, Middleware) { app.use('/test-plugin/*', Middleware(dirname, ['styles'], { __dirname, })) }, connected(app, db, dirname) { require('./services')(app,db, dirname) } })","title":"Plugins"},{"location":"plugins/#plugins","text":"","title":"Plugins"},{"location":"plugins/#riotjs-plugins","text":"RiotJS Plugins are configured in the ./plugins.js . Before installing plugins you should consider how they work on the server environment. By default there are serveral plugins which provide functionality for frontless. It is not recommended to delete initial code from ./plugins.js","title":"RiotJS Plugins"},{"location":"plugins/#frontless-plugins","text":"Frontless provides a simple plugin api. A frontless Plugin installation A plugin must be placed inside components directory. Then you need to call install on the plugin entry point const {install, withPlugins} = require('components/utils/plugins') const pluginExample = require('components/nesterow/frontless-plugin') install(pluginExample) Plugin initialization Depending on the purpose, a plugin can have three initialization steps: 1. setup - calls when Frontless initialized express 2. setupSSR - calls before SSR middlewares are initialized 3. connected - calls after database in connected Example plugin entry: const Middleware = require('components/utils/middleware') module.exports = ({ name: 'Example plugin', setup(app, dirname) { app.use((req, res, next) => { console.log('Example plugin middleware') next(); }) }, setupSSR(app, dirname, Middleware) { app.use('/test-plugin/*', Middleware(dirname, ['styles'], { __dirname, })) }, connected(app, db, dirname) { require('./services')(app,db, dirname) } })","title":"Frontless Plugins"},{"location":"routing/","text":"Routing All files ending with *.riot extension that placed in the pages directory become site pages. It works similar to php scripts or html pages. For example: index.riot -> GET / , page.riot -> GET /page . URL Query on server side Every Riot component on the server side has access to current express.js request context. Accessing request context using method fetch export default { async fetch(props){ const {req} = props; console.log(req.query) } } Accessing request context using property export default { async myMethod(){ const {req} = this; console.log(req.query) } } Positional arguments Positional URL arguments in Frontless are drop-in replacement for complex routing schemas. Passing a positional argument to the page is possible trough @ modifier. A semicolon-separated string after @ will be parsed as positional arguments. For example consider following request: GET /page@some_id;data?q=1 This request will fetch page.riot and pass positional arguments into 'request.params.args': export default { async fetch(props){ const {req} = props; const [user_id, data] = req.params.args; } } Push URL state It is possible to cache page state into URL using HTML5 history API without reloading current location. In order to achieve this behaviour use method this.pushState([...args], {...query}) . Example: // If userId = 10, age = 35 // this would result to: http://example.com/page@10?age=35 export default { cacheState(){ const {userId, age} = this.state this.pushQuery([userId], { age, }) } } Redirects Redirects work the same way on client and server. Use this.redirect('/location', [...args], {...query}) Example: // If user is not logged in // this would result to: http://example.com/login?backTo=/dashboard export default { onMounted(){ if (!this.isLoggedIn()) this.redirect('/login', [], { backTo: '/dashboard'}) } } Reloading location Calling this.reload() would result to reloding of current location.","title":"Routing"},{"location":"routing/#routing","text":"All files ending with *.riot extension that placed in the pages directory become site pages. It works similar to php scripts or html pages. For example: index.riot -> GET / , page.riot -> GET /page .","title":"Routing"},{"location":"routing/#url-query-on-server-side","text":"Every Riot component on the server side has access to current express.js request context. Accessing request context using method fetch export default { async fetch(props){ const {req} = props; console.log(req.query) } } Accessing request context using property export default { async myMethod(){ const {req} = this; console.log(req.query) } }","title":"URL Query on server side"},{"location":"routing/#positional-arguments","text":"Positional URL arguments in Frontless are drop-in replacement for complex routing schemas. Passing a positional argument to the page is possible trough @ modifier. A semicolon-separated string after @ will be parsed as positional arguments. For example consider following request: GET /page@some_id;data?q=1 This request will fetch page.riot and pass positional arguments into 'request.params.args': export default { async fetch(props){ const {req} = props; const [user_id, data] = req.params.args; } }","title":"Positional arguments"},{"location":"routing/#push-url-state","text":"It is possible to cache page state into URL using HTML5 history API without reloading current location. In order to achieve this behaviour use method this.pushState([...args], {...query}) . Example: // If userId = 10, age = 35 // this would result to: http://example.com/page@10?age=35 export default { cacheState(){ const {userId, age} = this.state this.pushQuery([userId], { age, }) } }","title":"Push URL state"},{"location":"routing/#redirects","text":"Redirects work the same way on client and server. Use this.redirect('/location', [...args], {...query}) Example: // If user is not logged in // this would result to: http://example.com/login?backTo=/dashboard export default { onMounted(){ if (!this.isLoggedIn()) this.redirect('/login', [], { backTo: '/dashboard'}) } }","title":"Redirects"},{"location":"routing/#reloading-location","text":"Calling this.reload() would result to reloding of current location.","title":"Reloading location"},{"location":"server_rendering/","text":"SSR The pages in Frontless are rendered after all fetch operations in children components are complete. Which means you can make asyncronous queries in children components and don't worry that the server return markup before data is fetched. Layouts Frontless uses ejs to render page layouts. The layouts located inside pages/layouts directory. In order to render your page with specific layout just include corresponding property to the root component. By default Frontless uses base layout. Example: export default { layout: 'base' } Fetching data Whenever a riot component has the fetch method returning a Promise, the server will wait until it resolves. Example: export default { async fetch(props){ const data = await someDbQuery() this.update(data) } } Component's state It doesn't matter whether you change compenents state on the server side or in the browser. The initial state of the components on the client side will resolve to the last component's state on the server side. Server sent state Some API requests can return a ready view-model for a specific component. After it happens, the target component will update its state from received response. This is convenient whenever you want to update the view after a request is done. Given that, the server should return a ready view-model which eliminates extra steps you would do to handle response. Normally, you should follow 3 steps to make it work: Give your component an unique id: export default { id: 'message', // target id state: { message:'' } ... } Then, on the server side use method app.setState() to compose a response: app.use('myservice',{ async create(data){ return app.setState('message', { message: 'Hello!' }) } }) After that, whenever you call myservice the component message will automatically update on response. client.service('myservice').create({}) Notice that you don't need to handle API call as the server supposed to return ready view-model for your component. The UI will update automatically. However, you still nedd to handle loading states and errors.","title":"SSR"},{"location":"server_rendering/#ssr","text":"The pages in Frontless are rendered after all fetch operations in children components are complete. Which means you can make asyncronous queries in children components and don't worry that the server return markup before data is fetched.","title":"SSR"},{"location":"server_rendering/#layouts","text":"Frontless uses ejs to render page layouts. The layouts located inside pages/layouts directory. In order to render your page with specific layout just include corresponding property to the root component. By default Frontless uses base layout. Example: export default { layout: 'base' }","title":"Layouts"},{"location":"server_rendering/#fetching-data","text":"Whenever a riot component has the fetch method returning a Promise, the server will wait until it resolves. Example: export default { async fetch(props){ const data = await someDbQuery() this.update(data) } }","title":"Fetching data"},{"location":"server_rendering/#components-state","text":"It doesn't matter whether you change compenents state on the server side or in the browser. The initial state of the components on the client side will resolve to the last component's state on the server side.","title":"Component's state"},{"location":"server_rendering/#server-sent-state","text":"Some API requests can return a ready view-model for a specific component. After it happens, the target component will update its state from received response. This is convenient whenever you want to update the view after a request is done. Given that, the server should return a ready view-model which eliminates extra steps you would do to handle response. Normally, you should follow 3 steps to make it work: Give your component an unique id: export default { id: 'message', // target id state: { message:'' } ... } Then, on the server side use method app.setState() to compose a response: app.use('myservice',{ async create(data){ return app.setState('message', { message: 'Hello!' }) } }) After that, whenever you call myservice the component message will automatically update on response. client.service('myservice').create({}) Notice that you don't need to handle API call as the server supposed to return ready view-model for your component. The UI will update automatically. However, you still nedd to handle loading states and errors.","title":"Server sent state"},{"location":"utils/","text":"Utils General purpose utils. components/utils serializeForm() Serialize an HTML form to JSON Object. Synopsis: serializeForm(HTMLFormElement, [...omit]) Usage: import {serializeForm} from 'components/utils' const formData = serializeForm(HTMLFormElement, ['fieldName']) SSR Middleware components/utils/middleware.js Resolves pages at given location an reders them. Usage: const FrontlessMiddleware = require('components/utils/middleware') app.use('/*@:args', FrontlessMiddleware(__dirname, ['styles'])) app.use('/*', FrontlessMiddleware(__dirname, ['styles']))","title":"Utils"},{"location":"utils/#utils","text":"General purpose utils. components/utils","title":"Utils"},{"location":"utils/#serializeform","text":"Serialize an HTML form to JSON Object. Synopsis: serializeForm(HTMLFormElement, [...omit]) Usage: import {serializeForm} from 'components/utils' const formData = serializeForm(HTMLFormElement, ['fieldName'])","title":"serializeForm()"},{"location":"utils/#ssr-middleware","text":"components/utils/middleware.js Resolves pages at given location an reders them. Usage: const FrontlessMiddleware = require('components/utils/middleware') app.use('/*@:args', FrontlessMiddleware(__dirname, ['styles'])) app.use('/*', FrontlessMiddleware(__dirname, ['styles']))","title":"SSR Middleware"}]}